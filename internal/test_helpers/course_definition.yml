slug: "sqlite"
name: "Build your own SQLite"
description_md: |
  In this challenge, you'll build a barebones SQLite implementation that supports
  basic SQL statements like SELECT/INSERT.

  Along the way, you'll learn about SQLite's [file format](https://sqlite.org/fileformat.html), how indexed data is
  [stored in B-trees](https://jvns.ca/blog/2014/10/02/how-does-sqlite-work-part-2-btrees/) and more.
completion_percentage: 5

supported_languages: ["python"]
early_access_languages: []
starter_repos:
  python: https://github.com/codecrafters-io/sqlite-starter-python

marketing:
  description: Learn about SQLite's file format, how indexed data is stored in B-trees and more.
  difficulty: hard
  introduction_md: |
    In this challenge, you'll build a barebones SQLite implementation that supports
    basic SQL statements like SELECT/INSERT. Along the way, you'll learn about SQLite's
    [file format](https://sqlite.org/fileformat.html), how indexed data is
    stored in B-trees and more.

stages:
  - slug: "init"
    name: "Print number of tables"
    description_md: |
      Welcome to Build Your Own SQLite!

      Now that we've got your starter repository setup, let's start with the first stage.

      In this stage, you'll implement one of SQLite's
      [dot-commands](https://www.sqlite.org/cli.html#special_commands_to_sqlite3_dot_commands_): `.dbinfo`. This
      command prints metadata about a SQLite database file.

      The command is executed like this:

      ```
      $ sqlite3 test.db .dbinfo
      ```

      It prints output in this format:

      ```
      database page size:  4096
      write format:        1
      read format:         1

      ...

      number of tables:    5
      schema size:         330
      data version:        1
      ```

      We're only going to focus on one of these values: `number of tables`. To find the number of tables, you'll need
      to count the number of rows in the
      [`sqlite_schema`](https://www.sqlite.org/fileformat.html#storage_of_the_sql_database_schema) table.

      The tester will execute your program like so:

      ```
      $ ./your_sqlite3.sh test.db .dbinfo
      ```

      And it'll expect output like this:

      ```
      number of tables: 2
      ```

      Read **"Passing the first stage"** in the README of your repository for instructions on how to pass this stage.
    marketing_md: |
      In this stage, you'll implement one of SQLite's
      [dot-commands](https://www.sqlite.org/cli.html#special_commands_to_sqlite3_dot_commands_): `.dbinfo`. This command
      prints metadata related a SQLite database, and you'll implement one of these values: the number of
      tables. You'll do this by parsing a file that uses the
      [SQLite database file format](https://www.sqlite.org/fileformat.html).

  - slug: "table_names"
    name: "Print table names"
    description_md: |
      In this stage, you'll implement another dot-command:
      [`.tables`](https://www.sqlite.org/cli.html#special_commands_to_sqlite3_dot_commands_).

      The tester will execute your program like so:

      ```
      $ ./your_sqlite3.sh test.db .tables
      ```

      And it'll expect output like this:

      ```
      table1 table2 table3
      ```

      You can test this with `sample.db` that is available in your starter repository:

      ```
      $ sqlite3 sample.db .tables
      apples   oranges
      ```

      Notice how the table names are formatted with more than one space between each other? That's because `sqlite3`
      formats its output so that every value has a fixed-width. Your program doesn't need to mimic this behaviour. Using
      just one space as a separator should work. Both `apples oranges` and <code>apples &nbsp; oranges</code> will pass
      our tests.
    marketing_md: |
      In this stage, you'll implement another dot-command:
      [`.tables`](https://www.sqlite.org/cli.html#special_commands_to_sqlite3_dot_commands_). Instead of just printing
      the count of tables like in the previous stage, you'll print out the names of tables too.

  - slug: "row_counts"
    name: "Count rows in a table"
    description_md: |
      Now that you've gotten your feet wet with the [SQLite database file format](https://www.sqlite.org/fileformat.html),
      it's time to move on to actual SQL!

      In this stage, your program will need to read the count of rows from a table.

      The tester will execute your program like so:

      ```
      $ ./your_sqlite3.sh test.db "SELECT COUNT(*) FROM apples"
      ```

      And it'll expect output like this:

      ```
      4
      ```

      You'll need to read the table's row from the [`sqlite_schema`](https://www.sqlite.org/schematab.html) table and
      follow the `rootpage` value to visit the page corresponding to the table. For now you can assume that the contents
      of the table are small enough to fit inside the root page. We'll deal with tables that span multiple pages in
      stage 7.

      Remember: You don't need to implement a full-blown SQL parser just yet. We'll get to that in the
      next stages. For now you can just split the input by " " and pick the last item to get the table name.
    marketing_md: |
      Now that you've gotten your feet wet with the [SQLite database file format](https://www.sqlite.org/fileformat.html),
      it's time to move on to actual SQL!
      In this stage, your sqlite3 implementation will need to execute a SQL statement of this form:
      `SELECT COUNT(*) FROM <table>`.

  - slug: "read_single_column"
    name: "Read data from a single column"
    description_md: |
      Now that you're comfortable with jumping across database pages, let's dig a little deeper and read data from
      rows in a table.

      Here's how the tester will execute your program:

      ```
      $ ./your_sqlite3.sh test.db "SELECT name FROM apples"
      ```

      and here's the output it expects:

      ```
      Granny Smith
      Fuji
      Honeycrisp
      Golden Delicious
      ```

      The order of rows returned doesn't matter.

      Rows are stored on disk in the [Record Format](https://www.sqlite.org/fileformat.html#record_format), which is
      just an ordered sequence of values. To extract data for a single column, you'll need to know the order of that
      column in the sequence. You'll need to parse the table's `CREATE TABLE` statement to do this. The `CREATE TABLE`
      statement is stored in the [`sqlite_schema`](https://www.sqlite.org/schematab.html) table's `sql` column.

      Not interested in implementing a SQL parser from scratch? [`sqlparse`](https://pypi.org/project/sqlparse/) is
      available as a dependency if you'd like to use it.
    marketing_md: |
      In this stage, your sqlite3 implementation will need to execute a SQL statement of this form:
      `SELECT <column> FROM <table>`.

  - slug: "read_multiple_columns"
    name: "Read data from multiple columns"
    description_md: |
      This stage is similar to the previous one, just that the tester will query for multiple columns instead of just
      one.

      Here's how the tester will execute your program:

      ```
      $ ./your_sqlite3.sh test.db "SELECT name, color FROM apples"
      ```

      and here's the output it expects:

      ```
      Granny Smith|Light Green
      Fuji|Red
      Honeycrisp|Blush Red
      Golden Delicious|Yellow
      ```

      Just like in the previous stage, the order of rows doesn't matter.
    marketing_md: |
      This stage is similar to the previous one, just that you'll read data from multiple columns instead of just one.
      In this stage, your sqlite3 implementation will need to execute a SQL statement of this form: `SELECT <column1>,<column2> FROM <table>`.

  - slug: "where"
    name: "Filter data with a WHERE clause"
    description_md: |
      In this stage, you'll support filtering records using a `WHERE` clause.

      Here's how the tester will execute your program:

      ```
      $ ./your_sqlite3.sh test.db "SELECT name, color FROM apples WHERE color = 'Yellow'"
      ```

      and here's the output it expects:

      ```
      Golden Delicious|Yellow
      ```

      For now you can assume that the contents of the table are small enough to fit inside the root page. We'll deal
      with tables that span multiple pages in the next stage.
    marketing_md: |
      In this stage, you'll filter records based on a `WHERE` clause. You'll assume that the query can't be served by
      an index, so you'll visit all records in a table and then filter out the matching ones.

  - slug: "table_scan"
    name: "Retrieve data using a full-table scan"
    description_md: |
      In this stage, you'll filter records based on a `WHERE` clause. You'll assume that the query can't be served
      Time to play with larger amounts of data!

      Here's how the tester will execute your program:

      ```
      $ ./your_sqlite3.sh test.db "SELECT description FROM apples"
      ```

      and here's the output it expects:

      ```
      Granny Smith|Light Green
      Fuji|Red
      Honeycrisp|Blush Red
      Golden Delicious|Yellow
      ```

      In this stage the tester will

      The tester is going to use a larger database this time, you can download it [here]() to test locally.
    marketing_md: |
      In this stage, you'll filter records based on a `WHERE` clause. You'll assume that the query can't be served by
      an index, so you'll visit all records in a table and then filter out the matching ones.

  - slug: "index_scan"
    name: "Retrieve data using an index"
    description_md: |
      TBD
    marketing_md: |
      This stage is similar to the previous one, but focuses on enhancing query performance using an index. In this
      stage, your program will need to read through millions of rows in under 5 seconds.
